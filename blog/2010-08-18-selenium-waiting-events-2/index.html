<!doctype html><html class="no-js" lang="ru"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title> Ожидание событий в Selenium RC, часть 2 -- AJAX</title><link rel="stylesheet" type="text/css" href="https://webdriver.ru/assets/css/styles_feeling_responsive.css" /> <script src="https://webdriver.ru/assets/js/modernizr.min.js"></script> <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script> <script> WebFont.load({ google: { families: [ 'Source Code Pro', 'Arimo::cyrillic', 'Philosopher::cyrillic' ] } }); </script> <noscript><link rel="preload" href='http://fonts.googleapis.com/css?family=Source+Code+Pro|Arimo|Philosopher' rel='stylesheet' type='text/css' /> </noscript><meta name="description" content="В предыдущей заметке мы сделали расширение Selenium RC, упрощающее операции, связанные с ожиданием загрузки страниц веб-приложения. Но те, кто занимается тестированием AJAX-приложений, с этими операциями сталкиваются редко, им приходится работать с другими событиями – появление и исчезновение элементов интерфейса, а также изменение их свойств (таких как, например, видимость или цвет). Поэтому сейчас мы добавим в наше расширение набор операций, предназначенных для ожидания таких событий" /><link rel="icon" sizes="32x32" href="https://webdriver.ru/assets/img/favicon-32x32.png" /><link rel="icon" sizes="192x192" href="https://webdriver.ru/assets/img/touch-icon-192x192.png" /><link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://webdriver.ru/assets/img/apple-touch-icon-180x180-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://webdriver.ru/assets/img/apple-touch-icon-152x152-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://webdriver.ru/assets/img/apple-touch-icon-144x144-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://webdriver.ru/assets/img/apple-touch-icon-120x120-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://webdriver.ru/assets/img/apple-touch-icon-114x114-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://webdriver.ru/assets/img/apple-touch-icon-76x76-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://webdriver.ru/assets/img/apple-touch-icon-72x72-precomposed.png" /><link rel="apple-touch-icon-precomposed" href="https://webdriver.ru/assets/img/apple-touch-icon-precomposed.png" /><meta name="msapplication-TileImage" content="https://webdriver.ru/assets/img/msapplication_tileimage.png" /><meta name="msapplication-TileColor" content="#fabb00" /><meta property="og:locale" content="en_EN" /><meta property="og:title" content="Ожидание событий в Selenium RC, часть 2 -- AJAX" /><meta property="og:description" content="В предыдущей заметке мы сделали расширение Selenium RC, упрощающее операции, связанные с ожиданием загрузки страниц веб-приложения. Но те, кто занимается тестированием AJAX-приложений, с этими операциями сталкиваются редко, им приходится работать с другими событиями – появление и исчезновение элементов интерфейса, а также изменение их свойств (таких как, например, видимость или цвет). Поэтому сейчас мы добавим в наше расширение набор операций, предназначенных для ожидания таких событий"/><meta property="og:url" content="https://webdriver.ru//blog/2010-08-18-selenium-waiting-events-2/" /><meta property="og:site_name" content="Selenium WebDriver: автоматизация веб-приложений" /><link type="text/plain" rel="author" href="https://webdriver.ru/humans.txt" /><body id="top-of-page" class="post"><div id="page"><div id="masthead-no-image-header"><div class="row"><div class="small-12 columns"> <a id="logo" href="https://webdriver.ru" title="Selenium WebDriver: автоматизация веб-приложений"> <img src="https://webdriver.ru/assets/img/logo.png" alt="Selenium WebDriver: автоматизация веб-приложений – "><h1>Selenium WebDriver</h1><h2>автоматизация веб-приложений</h2></a></div></div></div><div id="navigation" class="sticky"><nav class="top-bar" role="navigation" data-topbar><ul class="title-area"><li class="name"><h1 class="show-for-small-only"><a href="https://webdriver.ru" class="icon-tree"> Selenium WebDriver</a></h1><li class="toggle-topbar menu-icon"><a href="#"><span>Меню</span></a></ul><section class="top-bar-section"><ul class="right"><li class="divider"><li><a href="https://webdriver.ru/search/">Поиск</a></ul><ul class="left"><li link-url="/" page-url="/blog/2010-08-18-selenium-waiting-events-2/" ><a href="https://webdriver.ru/">Старт</a><li class="divider"><li link-url="/news/" page-url="/blog/2010-08-18-selenium-waiting-events-2/" ><a href="https://webdriver.ru/news/">Новости</a><li class="divider"><li link-url="/blog/" page-url="/blog/2010-08-18-selenium-waiting-events-2/" class="active"><a href="https://webdriver.ru/blog/">Блог</a><li class="divider"><li link-url="/trainings/" page-url="/blog/2010-08-18-selenium-waiting-events-2/" ><a href="https://webdriver.ru/trainings/">Обучение</a><li class="divider"><li link-url="http://software-testing.ru/forum/index.php?/forum/129-selenium-functional-testing/" page-url="/blog/2010-08-18-selenium-waiting-events-2/" ><a href="http://software-testing.ru/forum/index.php?/forum/129-selenium-functional-testing/" target="_blank">Форум</a><li class="divider"></ul></section></nav><div id="breadcrumb"><div class="row"><nav class="breadcrumbs bootstrap hidden-sm-down"> <a property="item" typeof="WebPage" href="/index.html"> <span class="icon-home" property="name"></span><meta property="position" content="1" /> </a> <a property="item" typeof="WebPage" href="/blog/index.html"> <span property="name">Блог</span><meta property="position" content="2" /> </a> <span property="name">Ожидание событий в Selenium RC, часть 2 -- AJAX</span><meta property="position" content="3" /></nav></div></div></div><div class="row t30"><div class="medium-8 columns"><article itemscope itemtype="http://schema.org/Article"><header> <span itemprop="name"><div class="date"><time class="icon-calendar pr20" datetime="2010-08-18" itemprop="datePublished"> 18 августа 2010 </time></div><h1>Ожидание событий в Selenium RC, часть 2 -- AJAX</h1></span></header><span itemprop="articleSection"><p>В <a href="/articles/8-selenium-waiting-events-1">предыдущей заметке</a> мы сделали расширение Selenium RC, упрощающее операции, связанные с ожиданием загрузки страниц веб-приложения. Но те, кто занимается тестированием AJAX-приложений, с этими операциями сталкиваются редко, им приходится работать с другими событиями – появление и исчезновение элементов интерфейса, а также изменение их свойств (таких как, например, видимость или цвет). Поэтому сейчас мы добавим в наше расширение набор операций, предназначенных для ожидания таких событий. Но сначала немного теории о том, как в целом устроена система команд в Selenium.<h2 id="система-командв-selenium">Система команд в Selenium</h2><p>Все команды, которые есть в Selenium, разделяются на три класса:<ul><li>действия (actions)<li>получатели данных (accessors)<li>проверки (assertions)</ul><p><strong>Действия</strong> – это команды, которые управляют состоянием тестируемого приложения, такие как <code class="highlighter-rouge">click</code>, <code class="highlighter-rouge">check</code>, <code class="highlighter-rouge">type</code>, <code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">fireEvent</code> и т.п.<p>Большая часть действий приводит к изменению состояния приложения – в результате выполнения такой команды либо отправляется запрос на сервер (например, проход по ссылке или отправка формы), либо происходят какие-то события в браузере (например, заполняются поля формы, устанавливаются cookies или отрабатывает javascript-функция).<p>Некоторые команды-действия сами ничего не делают, но управляют поведением других команд-действий, например <code class="highlighter-rouge">setTimeout</code>, <code class="highlighter-rouge">answerOnNextPrompt</code>, <code class="highlighter-rouge">chooseCancelOnNextConfirmation</code>.<p>Наконец, есть несколько команд, которые тоже почему-то относятся к действиям, но на самом деле это команды ожидания некоторого события. Это команды <code class="highlighter-rouge">waitForCondition</code>, <code class="highlighter-rouge">waitForPageToLoad</code>, <code class="highlighter-rouge">waitForPopUp</code> и <code class="highlighter-rouge">waitForFrameToLoad</code>, именно им была посящена предыдущая заметка (вообще-то команда <code class="highlighter-rouge">waitForCondition</code> может модифицировать состояние приложения, потому что в ней можно выполнить произвольный javascript-код, но теоретически она не должна иметь такого рода побочных эффектов).<p><strong>Получатели данных</strong> – это команды, предназначенные для получения информации о состоянии тестируемого приложения. В Selenium IDE все такие команды начинаются со слова “store” – <code class="highlighter-rouge">storeTitle</code>, <code class="highlighter-rouge">storeText</code>, <code class="highlighter-rouge">storeElementPresent</code> и т.д., они сохраняют полученную информацию о состоянии приложения в переменные, которые могут быть использованы в последующих командах.<p>В Selenium RC используется другая схема именования – имена получателей, возвращающих текстовое значение, начинаются со слова “get”, а имена получателей, возвращающих булевское значение (да/нет, true/false), начинаются со слова “is”. Например, <code class="highlighter-rouge">getTitle</code>, <code class="highlighter-rouge">getText</code>, <code class="highlighter-rouge">getAttribute</code>, но – <code class="highlighter-rouge">isChecked</code>, <code class="highlighter-rouge">isElementPresent</code>, <code class="highlighter-rouge">isVisible</code>.<p><strong>Проверки</strong> как самостоятельные команды существуют только в Selenium IDE. Они генерируются автоматически, для каждого получателя данных создается шесть проверок: прямая и обратная проверки в трёх режимах – assert, verify и waitFor. Например, для команды <code class="highlighter-rouge">storeElementPresent</code> создаются следующие проверки: <code class="highlighter-rouge">assertElementPresent</code>, <code class="highlighter-rouge">assertElementNotPresent</code>, <code class="highlighter-rouge">verifyElementPresent</code>, <code class="highlighter-rouge">verifyElementNotPresent</code>, <code class="highlighter-rouge">waitForElementPresent</code>, <code class="highlighter-rouge">waitForElementNotPresent</code>.<p>В Selenium RC проверки реализуются как комбинация получателя данных и подходящего метода из используемого фреймворка для разработки тестов.<p>Так, скажем, для фреймворка <a href="http://testng.org/">TestNG (Java)</a> проверки типа “assert” будут выглядеть примерно так:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">assertEquals</span><span class="o">(</span><span class="n">getText</span><span class="o">(</span><span class="s">"id=result"</span><span class="o">),</span> <span class="s">"expected value"</span><span class="o">);</span>
<span class="n">assertFalse</span><span class="o">(</span><span class="n">isElementPresent</span><span class="o">(</span><span class="s">"id=error"</span><span class="o">));</span></code></pre></figure><p>А для фреймворка <a href="http://docs.python.org/library/unittest.html">Python unittest</a> аналогичные проверки будут такими:<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s">"expected value"</span><span class="p">,</span> <span class="n">sel</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="s">"id=result"</span><span class="p">))</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="n">sel</span><span class="o">.</span><span class="n">is_element_present</span><span class="p">(</span><span class="s">"id=error"</span><span class="p">))</span></code></pre></figure><p>Чуть сложнее устроены проверки типа “verify”. Они отличаются от проверок типа “assert” тем, что не должны немедленно прерывать выполнение теста, вместо этого сообщение об ошибке вносится в специальный список. Этот способ используется для выполнения некритичных проверок, после которых можно продолжать выполнение даже если проверка дала отрицательный результат. При этом тест отрабатывает до конца, и если список ошибок непустой, он всё-таки помечается как завершившийся неуспешно.<p>Тестовые фреймворки как правило не имеют встроенной поддержки для проверок такого типа.<p>Для тех, кто разрабатывает тесты на языке Java, ситуация несколько лучше. В TestNG проверки типа “verify” реализованы во вспомогательном классе <code class="highlighter-rouge">SeleneseTestNgHelper</code>, о котором мы уже говорили в <a href="http://software-testing.ru/library/testing/functional-testing/1042-selenium-auto-screenshoots">предыдущих заметках</a>. Выглядеть это будет следующим образом:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">verifyEquals</span><span class="o">(</span><span class="n">getText</span><span class="o">(</span><span class="s">"id=result"</span><span class="o">),</span> <span class="s">"expected value"</span><span class="o">);</span>
<span class="n">verifyFalse</span><span class="o">(</span><span class="n">isElementPresent</span><span class="o">(</span><span class="s">"id=error"</span><span class="o">));</span></code></pre></figure><p>Аналогичная поддержка проверок типа “verify” есть и в некоторых других фреймворках, в частности JUnit для Java и Groovy.<p>А вот для проверок типа “waitFor” нет поддержки ни в одном известном мне фреймворке или расширении для Selenium. Поэтому мы реализуем эту поддержку самостоятельно для TestNG (а если вы пользуетесь чем-нибудь другим – можете адаптировать это для своего фреймворка самостоятельно).<p>Но сначала ещё чуть-чуть поговорим о том, почему эти команды играют столь важную роль при тестировании AJAX-приложений<h2 id="ajax-и-команды-проверки-типа-waitfor">AJAX и команды-проверки типа “waitFor”</h2><p>В “классических” веб-приложениях тесты устроены таким образом, что мы сначала выполняем некоторую последовательность действий, завершающуюся отправкой запроса на веб-сервер. Затем мы должны дождаться, пока браузер получит от сервера ответ, после чего приступить к его проверке. И для ожидания ответа обычно используется команда <code class="highlighter-rouge">waitForPageToLoad</code>.<p>Но для AJAX-приложений этот способ не годится, потому что обращения к серверу выполняются в “фоновом режиме”, после чего обновляются только отдельные части страницы, полностью страница не перегружается. Поэтому команда waitForPageToLoad оказывается совершенно бесполезной.<p>Вместо ожидания загрузки страницы в таких приложениях мы должны определить некоторые другие критерии завершения обработки запроса. Это может быть появление или исчезновение каких-либо элементов на странице, либо изменение их свойств – видимость, цвет, расположение и т.д. Соответственно, нам нужны команды для ожидания таких событий – а это и есть те самые команды-проверки типа “waitFor”, о которых шла речь выше.<p>Ну что ж, пришла пора заняться реализацией всех этих проверок.<h2 id="реализация-waitfor-проверок">Реализация waitFor-проверок</h2><p>За основую релизации методов ожидания можно взять код, который генерирует Selenium IDE для проверок типа “waitFor”.<p>Вот что там предлагается, например, для команды waitForVisible:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;;</span> <span class="n">second</span><span class="o">++)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">second</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="mi">60</span><span class="o">)</span> <span class="n">fail</span><span class="o">(</span><span class="s">"timeout"</span><span class="o">);</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">selenium</span><span class="o">.</span><span class="na">isVisible</span><span class="o">(</span><span class="s">"id=result"</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
  <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p>Идея вполне очевидна – в цикле раз в секунду проверять, виден ли нужный элемент. Если виден – ожидание прекращается. А если прошло уже достаточно много проверок (60) и все неуспешные – тогда можно завершить тест с сообщением о том, что время ожидания истекло.<p>Разумеется, невозможно каждый раз, когда требуется сделать такого рода проверку, вставлять столь громоздкий кусок кода. Давайте оформим его в виде вспомогательного метода, вот такого:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">waitForVisible</span><span class="o">(</span><span class="n">String</span> <span class="n">locator</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;;</span>  <span class="n">second</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">second</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span>  <span class="nf">AssertionError</span><span class="o">(</span><span class="s">"timeout"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">selenium</span><span class="o">.</span><span class="na">isVisible</span><span class="o">(</span><span class="n">locator</span><span class="o">))</span>  <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span>  <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure><p>Теперь посмотрим пристально, и попробуем понять, сколько времени будет ожидать этот метод, прежде чем сообщит о неудаче? Думаете, 60 секунд? Отнюдь! Например, на моём ноутбуке, где я пишу эту заметку, он работает примерно 140 секунд. Дело в том, что на самом деле в цикле считаются не секунды, а количество попыток. Между попытками проходит секунда, но сами попытки тоже требуют определённого времени, причём весьма существенного. То есть у меня 60 секунд ушло на ожидание, и ещё 80 секунд заняли обращения к Selenium.<p>Давайте исправим это так, чтобы метод на самом деле выполнял проверки в течение указанного <strong>времени</strong>:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">waitForVisible</span><span class="o">(</span><span class="n">String</span> <span class="n">locator</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">start</span>  <span class="o">+</span> <span class="mi">60000</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">selenium</span><span class="o">.</span><span class="na">isVisible</span><span class="o">(</span><span class="n">locator</span><span class="o">))</span> <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span>  <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span>  <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">throw</span>  <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">(</span><span class="s">"timeout"</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p>Кроме того, хорошо бы сделать время ожидания параметром, а также дать возможность настраивать дефолтное время ожидания и промежуток между попытками:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">waitForVisible</span><span class="o">(</span><span class="n">String</span> <span class="n">locator</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">waitForVisible</span><span class="o">(</span><span class="n">locator</span><span class="o">,</span>  <span class="n">getDefaultTimeoutWaitFor</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">waitForVisible</span><span class="o">(</span><span class="n">String</span>  <span class="n">locator</span><span class="o">,</span><span class="err"> </span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="n">pause</span> <span class="o">=</span> <span class="n">getAttemptsInterval</span><span class="o">();</span>
  <span class="kt">long</span>  <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span>  <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">selenium</span><span class="o">.</span><span class="na">isVisible</span><span class="o">(</span><span class="n">locator</span><span class="o">))</span> <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">pause</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span>  <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">throw</span>  <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">(</span><span class="s">"timeout"</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p>Далее мы должны были бы создать аналогичные методы для всех команд получения данных, но это не очень хорошо, потому что у нас получится множество методов, похожих как близнецы-братья.<p>Более правильный способ состоит в том, чтобы отделить “логику ожидания” от “логики проверки”, создать один унивесальный метод ожидания, который может проверять разные условия. Именно так, кстати, реализованы проверки типа “assert” и “verify” – в них комбинируется единый универсальный метод проверки с семейством специализированных методов получения данных.<p>Мы сделаем такую реализацию, в которой проверка-ожидание будет выглядеть следующим образом:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">boolean</span><span class="err"> </span><span class="n">res</span> <span class="o">=</span> <span class="n">selenium</span><span class="o">.</span><span class="na">waitFor</span><span class="o">(</span><span class="n">Visible</span><span class="o">(</span><span class="s">"id=result"</span><span class="o">));</span></code></pre></figure><p>То есть у нас будет унивесальный метод waitFor (а также waitForNot) и семейство методов, реализующих логику проверки, по одному для каждой операции получения данных.<p>Кроме того, мы сделаем так, чтобы при неуспешном завершении он не прерывал выполнение теста, а просто возвращал false (а при успешном завершении, соответственно, true). Это даст возможность разработчику тестов самостоятельно принять решение о том, что делать в той или иной ситуации. Если он решит, что тест должен прерываться, можно добиться этого эффекта путём комбинирования с методом <code class="highlighter-rouge">assertTrue</code>:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">assertTrue</span><span class="o">(</span><span class="n">selenium</span><span class="o">.</span><span class="na">waitFor</span><span class="o">(</span><span class="n">Visible</span><span class="o">(</span><span class="s">"id=result"</span><span class="o">)));</span></code></pre></figure><p>Итак, вот как устроен универсальный метод ожидания, который мы поместим в класс <code class="highlighter-rouge">WaitingSelenium</code>:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span><span class="err"> </span><span class="kt">boolean</span> <span class="nf">waitFor</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span>  <span class="nf">waitFor</span><span class="o">(</span><span class="n">condition</span><span class="o">,</span> <span class="n">getDefaultTimeoutWaitFor</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">public</span><span class="err"> </span><span class="kt">boolean</span> <span class="nf">waitFor</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="n">pause</span> <span class="o">=</span>  <span class="n">getAttemptsInterval</span><span class="o">();</span>
  <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>

  <span class="k">while</span> <span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">checkConditionWith</span><span class="o">(</span><span class="k">this</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">pause</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
     <span class="err"> </span><span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure><p>На вход он получает параметр типа <code class="highlighter-rouge">Condition</code>, это интерфейс, в котором имеется всего один метод:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Condition</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="nf">checkConditionWith</span><span class="o">(</span><span class="n">Selenium</span> <span class="n">selenium</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure><p>А вот метод Visible, который реализует проверку того, виден или нет элемент с заданным локатором:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Condition</span> <span class="nf">Visible</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">locator</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">Condition</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkConditionWith</span><span class="o">(</span><span class="n">Selenium</span> <span class="n">selenium</span><span class="o">)</span>  <span class="o">{</span>
      <span class="k">return</span> <span class="n">selenium</span><span class="o">.</span><span class="na">isVisible</span><span class="o">(</span><span class="n">locator</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">};</span>
<span class="o">}</span></code></pre></figure><p>Вот и всё. Теперь надо наделать много методов, аналогичных <code class="highlighter-rouge">Visible</code> – для всех команд получения данных, и можно пользоваться. Впрочем, всё это уже есть в приложенном архиве, содержащем код – в класс <code class="highlighter-rouge">WaitingSelenium</code> добавлены два универсальных метода ожидания, а в классе <code class="highlighter-rouge">SeleneseTestNgHelper</code> появилась целая серия методов, создающих проверки для практически всех команд-получателей данных. Пропущены команды <code class="highlighter-rouge">getAllButtons</code>, <code class="highlighter-rouge">getAllFields</code>, <code class="highlighter-rouge">getAllLinks</code>, <code class="highlighter-rouge">getAllWindowIds</code>, <code class="highlighter-rouge">getAllWindowNames</code> и <code class="highlighter-rouge">getAllWindowTitles</code>, для которых проверки типа waitFor не имеют особого смысла, но про которые мы ещё поговорим в будущем. Кроме того, нет проверок для команды <code class="highlighter-rouge">storeLogMessages</code>, которая просто заглушка без реализации, и для команд <code class="highlighter-rouge">WhetherThisFrameMatchFrameExpression</code> и <code class="highlighter-rouge">WhetherThisWindowMatchFrameExpression</code>, которые предназначены для сугубо служебных целей.<p>И напоследок ещё одно замечание – условия для проверки можно делать сколь угодно сложными, они не обязательно должны состоять только из одной команды Selenium.<p>А в следущей заметке серии мы реализуем ещё два метода ожидания, которых в Selenium нет вообще, но которые тоже бывают полезны при тестировании AJAX-приложений – <code class="highlighter-rouge">waitForChange</code> и <code class="highlighter-rouge">waitForStopChanges</code>.<p>В приложении находится проект Eclipse, содержащий исходный код расширения WaitingSelenium и модифицированный класс <code class="highlighter-rouge">SeleneseTestNgHelper</code>, в которых реализованы проверки-ожидания: <a href="http://software-testing.ru/files/library/barancev/waiting_selenium/WaitingSelenium2.zip">WaitingSelenium2.zip</a> </span><div id="page-meta" class="t30"><p> <time class="icon-calendar pr20" datetime="2010-08-18" itemprop="datePublished"> 18 августа 2010 </time> <span class="icon-archive pr20">&nbsp;<a href="https://webdriver.ru/blog/">БЛОГ</a></span> <br /> <span class="pr20"></span><ul class="pager"><li><a href="https://webdriver.ru/blog/2010-08-11-selenium-waiting-events-1/">&larr; Ожидание событий в Selenium RC, часть 1</a><li>&nbsp;|&nbsp;<li><a href="https://webdriver.ru/blog/2011-01-11-selenium-pageshots/">Selenium: Снятие скриншотов веб-страницы целиком &rarr;</a></ul></div></article></div><div class="medium-4 columns"><aside><div class="panel radius"><h3>Новые публикации</h3><ul class="side-nav"><li><a href="https://webdriver.ru/news/2019-11-25-seleniumconf-london/">Опубликованы материалы конференции SeleniumConf London 2019</a><li><a href="https://webdriver.ru/news/2019-11-18-selenium-dev/">Запущен новый сайт selenium.dev</a><li><a href="https://webdriver.ru/news/2018-07-10-selenium-314/">Вышел релиз Selenium 3.14</a><li><a href="https://webdriver.ru/news/2018-07-10-selenium-313/">Вышел релиз Selenium 3.13</a><li><a href="https://webdriver.ru/news/2018-06-25-selenium-312/">Вышел релиз Selenium 3.12</a></ul></div><div class="panel radius"><h3>Ближайшие тренинги</h3><ul class="side-nav"><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/242-selenium-webdriver"><time class="icon-calendar date"> 18 июня 2021</time><br>Selenium WebDriver: полное руководство</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/226-csharp-for-testers"><time class="icon-calendar date"> 25 июня 2021</time><br>Программирование на C# для тестировщиков</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/19-performance-testing-jmeter"><time class="icon-calendar date"> 2 июля 2021</time><br>Тестирование производительности: JMeter 5</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/185-selenium"><time class="icon-calendar date"> 9 июля 2021</time><br>Selenium IDE 3: стартовый уровень</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/1-java-for-testers"><time class="icon-calendar date"> 9 июля 2021</time><br>Программирование на Java для тестировщиков</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/46-test-design"><time class="icon-calendar date"> 16 июля 2021</time><br>Практикум по тест-дизайну 2.0</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/189-web"><time class="icon-calendar date"> 16 июля 2021</time><br>Тестирование веб-приложений 2.0</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/234-functional-test-automation"><time class="icon-calendar date"> 23 июля 2021</time><br>Автоматизация функционального тестирования</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/233-python"><time class="icon-calendar date"> 23 июля 2021</time><br>Программирование на Python для тестировщиков</a></span></ul></div></aside></div></div><footer id="footer-content" class="bg-grau"><div id="footer"><div class="row"><div class="medium-6 large-5 columns"><h5 class="shadow-black">О нас</h5><ul class="no-bullet shadow-black"><li><a href="https://webdriver.ru/info/">Пишем про Selenium на русском языке</a></ul></div><div class="small-6 medium-3 large-3 large-offset-1 columns"><h5 class="shadow-black">RSS/Atom</h5><ul class="no-bullet shadow-black"><li > <a href="" title=""></a><li > <a href="/feed.xml" title="Subscribe to RSS Feed">RSS</a><li > <a href="/atom.xml" title="Subscribe to Atom Feed">Atom</a></ul></div><div class="small-6 medium-3 large-3 columns"><h5 class="shadow-black">Благодарности</h5><ul class="no-bullet shadow-black"><li > <a href="" title=""></a><li class="services-newsletter" > <a href="https://jekyllrb.com/" target="_blank" title="Built with Jekyll">Built with Jekyll</a><li class="services-newsletter" > <a href="https://github.com/Phlow/feeling-responsive" target="_blank" title="Design by Phlow">Design by Phlow</a><li class="services-newsletter" > <a href="http://foundation.zurb.com/" target="_blank" title="Built on Foundation">Built on Foundation</a></ul></div></div></div><div id="subfooter"><nav class="row"><section id="subfooter-left" class="b30 small-12 medium-6 columns credits"></section><section id="subfooter-right" class="small-12 medium-6 columns social-icons"><ul class="inline-list"></ul></section></nav></div></footer><script src="https://webdriver.ru/assets/js/javascript.min.js"></script></div>
