<!doctype html><html class="no-js" lang="ru"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title> Selenium: ожидание завершения всех AJAX-запросов</title><link rel="stylesheet" type="text/css" href="https://webdriver.ru/assets/css/styles_feeling_responsive.css" /> <script src="https://webdriver.ru/assets/js/modernizr.min.js"></script> <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script> <script> WebFont.load({ google: { families: [ 'Source Code Pro', 'Arimo::cyrillic', 'Philosopher::cyrillic' ] } }); </script> <noscript><link rel="preload" href='http://fonts.googleapis.com/css?family=Source+Code+Pro|Arimo|Philosopher' rel='stylesheet' type='text/css' /> </noscript><meta name="description" content="В последнее время развелось очень много различных AJAX-приложений. По сути автоматизация тестирования такого приложения не отличается от автоматизации тестирования обычного WEB-приложения, но есть несколько тонкостей. Одна из тонкостей — это как раз ожидание завершения всех AJAX-запросов. Например, если отметка некого checkbox&#39;а на странице вызывает обновление какого-нибудь select&#39;a по AJAX-запросу, то тест, который сразу после отметки выбирает конкретный option, свалится, т.к. этого option&#39;a там не будет. А всё потому, что сам тест выполняется намного быстрее чем AJAX-запрос на обновление списка. В данном случае у автоматизатора есть несколько выходов" /><link rel="icon" sizes="32x32" href="https://webdriver.ru/assets/img/favicon-32x32.png" /><link rel="icon" sizes="192x192" href="https://webdriver.ru/assets/img/touch-icon-192x192.png" /><link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://webdriver.ru/assets/img/apple-touch-icon-180x180-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://webdriver.ru/assets/img/apple-touch-icon-152x152-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://webdriver.ru/assets/img/apple-touch-icon-144x144-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://webdriver.ru/assets/img/apple-touch-icon-120x120-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://webdriver.ru/assets/img/apple-touch-icon-114x114-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="76x76" href="https://webdriver.ru/assets/img/apple-touch-icon-76x76-precomposed.png" /><link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://webdriver.ru/assets/img/apple-touch-icon-72x72-precomposed.png" /><link rel="apple-touch-icon-precomposed" href="https://webdriver.ru/assets/img/apple-touch-icon-precomposed.png" /><meta name="msapplication-TileImage" content="https://webdriver.ru/assets/img/msapplication_tileimage.png" /><meta name="msapplication-TileColor" content="#fabb00" /><meta property="og:locale" content="en_EN" /><meta property="og:title" content="Selenium: ожидание завершения всех AJAX-запросов" /><meta property="og:description" content="В последнее время развелось очень много различных AJAX-приложений. По сути автоматизация тестирования такого приложения не отличается от автоматизации тестирования обычного WEB-приложения, но есть несколько тонкостей. Одна из тонкостей — это как раз ожидание завершения всех AJAX-запросов. Например, если отметка некого checkbox&#39;а на странице вызывает обновление какого-нибудь select&#39;a по AJAX-запросу, то тест, который сразу после отметки выбирает конкретный option, свалится, т.к. этого option&#39;a там не будет. А всё потому, что сам тест выполняется намного быстрее чем AJAX-запрос на обновление списка. В данном случае у автоматизатора есть несколько выходов"/><meta property="og:url" content="https://webdriver.ru//blog/2011-01-11-waiting-for-ajax/" /><meta property="og:site_name" content="Selenium WebDriver: автоматизация веб-приложений" /><link type="text/plain" rel="author" href="https://webdriver.ru/humans.txt" /><body id="top-of-page" class="post"><div id="page"><div id="masthead-no-image-header"><div class="row"><div class="small-12 columns"> <a id="logo" href="https://webdriver.ru" title="Selenium WebDriver: автоматизация веб-приложений"> <img src="https://webdriver.ru/assets/img/logo.png" alt="Selenium WebDriver: автоматизация веб-приложений – "><h1>Selenium WebDriver</h1><h2>автоматизация веб-приложений</h2></a></div></div></div><div id="navigation" class="sticky"><nav class="top-bar" role="navigation" data-topbar><ul class="title-area"><li class="name"><h1 class="show-for-small-only"><a href="https://webdriver.ru" class="icon-tree"> Selenium WebDriver</a></h1><li class="toggle-topbar menu-icon"><a href="#"><span>Меню</span></a></ul><section class="top-bar-section"><ul class="right"><li class="divider"><li><a href="https://webdriver.ru/search/">Поиск</a></ul><ul class="left"><li link-url="/" page-url="/blog/2011-01-11-waiting-for-ajax/" ><a href="https://webdriver.ru/">Старт</a><li class="divider"><li link-url="/news/" page-url="/blog/2011-01-11-waiting-for-ajax/" ><a href="https://webdriver.ru/news/">Новости</a><li class="divider"><li link-url="/blog/" page-url="/blog/2011-01-11-waiting-for-ajax/" class="active"><a href="https://webdriver.ru/blog/">Блог</a><li class="divider"><li link-url="/trainings/" page-url="/blog/2011-01-11-waiting-for-ajax/" ><a href="https://webdriver.ru/trainings/">Обучение</a><li class="divider"><li link-url="http://software-testing.ru/forum/index.php?/forum/129-selenium-functional-testing/" page-url="/blog/2011-01-11-waiting-for-ajax/" ><a href="http://software-testing.ru/forum/index.php?/forum/129-selenium-functional-testing/" target="_blank">Форум</a><li class="divider"></ul></section></nav><div id="breadcrumb"><div class="row"><nav class="breadcrumbs bootstrap hidden-sm-down"> <a property="item" typeof="WebPage" href="/index.html"> <span class="icon-home" property="name"></span><meta property="position" content="1" /> </a> <a property="item" typeof="WebPage" href="/blog/index.html"> <span property="name">Блог</span><meta property="position" content="2" /> </a> <span property="name">Selenium: ожидание завершения всех AJAX-запросов</span><meta property="position" content="3" /></nav></div></div></div><div class="row t30"><div class="medium-8 columns"><article itemscope itemtype="http://schema.org/Article"><header> <span itemprop="name"><div class="date"><time class="icon-calendar pr20" datetime="2011-01-11" itemprop="datePublished"> 11 января 2011 </time></div><h1>Selenium: ожидание завершения всех AJAX-запросов</h1></span></header><span itemprop="articleSection"><p><em>Это гостевая статья, написанная Виталием Помазенковым</em><p>В последнее время развелось очень много различных AJAX-приложений. По сути автоматизация тестирования такого приложения не отличается от автоматизации тестирования обычного WEB-приложения, но есть несколько тонкостей. Одна из тонкостей — это как раз ожидание завершения всех AJAX-запросов. Например, если отметка некого checkbox’а на странице вызывает обновление какого-нибудь select’a по AJAX-запросу, то тест, который сразу после отметки выбирает конкретный option, свалится, т.к. этого option’a там не будет. А всё потому, что сам тест выполняется намного быстрее чем AJAX-запрос на обновление списка.<p>В данном случае у автоматизатора есть несколько выходов.<p><strong>1. Поставить sleep после отметки checkbox’а.</strong><p>Это самое плохое и, к сожалению, чаще всего применяемое решение. Нам заранее не известно, сколько времени займёт выполнение AJAX-запроса, соответственно придётся задавать время ожидания исходя из минимально достаточного для большинства случаев. Например, 5 секунд. Когда таких ожиданий по 5 секунд наберётся достаточно много, наши тесты начнут выполняться очень долго, даже тогда, когда все AJAX-запросы выполняются быстро. Кроме того, иногда по разным причинам время выполнения AJAX-запроса может оказаться 5.2 секунды, в таких случаях мы будем получать ложные падения тестов, что тоже плохо.<p><strong>2. Воспользоваться классом <a href="http://release.seleniumhq.org/selenium-remote-control/0.9.2/doc/java/com/thoughtworks/selenium/Wait.html">Wait</a> и ждать пока <a href="http://release.seleniumhq.org/selenium-remote-control/0.9.2/doc/java/com/thoughtworks/selenium/Selenium.html#isElementPresent%28java.lang.String%29">Selenium#isElementPresent</a> не вернёт true для нужного option’а.</strong><p>Этот способ уже лучше, но всё равно не должен применяться, в будущем напишу подробно почему. Лучше вместо класса Wait использовать метод Selenium#waitForCondition, в котором и ждать появления требуемого элемента.<p><strong>3. Каким-то образом после отметки checkbox’а дождаться завершения всех AJAX-запросов и только после этого выбирать option.</strong><p>Этот способ рассмотрим более подробно, т.к. он является достаточно универсальным и простым с точки зрения автоматизатора.<p>В большинстве WEB-приложений для работы с AJAX используются специализированные библиотеки (jQuery, Prototype, Dojo и т.д.), предоставляющие разработчику более высокий уровень абстракции, чем стандартное API, а соответственно и большую гибкость.<p>Для того, чтобы в Selenium-тесте дождаться завершения всех AJAX-запросов, необходимо научиться следить за этими запросами глобально. В стандартном API нет возможности установки глобальных перехватчиков, но зато практически в каждой из сторонних библиотек такая возможность есть, хотя везде это делается по-своему. Вот пример, как можно дождаться завершения всех AJAX-запросов при использовании библиотеки jQuery:<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/**
 * Waits for all active jQuery AJAX requests to finish.
 *
 * @param timeout Timeout in milliseconds.
 * @throws SeleniumError If timeout is reached.
 */</span>
<span class="nx">Selenium</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">doWaitForJqueryAjaxRequests</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Selenium</span><span class="p">.</span><span class="nx">decorateFunctionWithTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">selenium</span><span class="p">.</span><span class="nx">browserbot</span><span class="p">.</span><span class="nx">getUserWindow</span><span class="p">().</span><span class="nx">jQuery</span><span class="p">.</span><span class="nx">active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">},</span> <span class="nx">timeout</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure><p>Здесь мы просто оборачиваем необходимое нам условие (количество активных AJAX-запросов равно нулю) в метод Selenium#decorateFunctionWithTimeout, который будет ожидать выполнения данного условия в течение указанного в timeout времени, и если дождётся, то метод будет успешно завершён, иначе будет выкинуто исключение SeleniumError.<p>Если описать на мета-языке то, что нам требуется для создания универсального метода ожидания, то получится примерно следующее:<ul><li>Определить, какие библиотеки используются для работы с AJAX.<li>Подождать завершения всех AJAX-запросов для каждой из используемых библиотек.</ul><p>Всё просто, осталось реализовать это на JavaScript и подключить в качестве расширения к Selenium RC либо к Selenium IDE, кому как нравится. При использовании Selenium RC для большей универсальности можно подгружать код расширения с помощью метода DefaultSelenium#setExtensionJs.<p>Вот готовая реализация (поддержаны jQuery, Prototype и Dojo):<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/**
 * Waits for all active AJAX requests to finish during specified timeout.
 * Works only for AJAX requests which are instantiated using one of the following frameworks:
 * jQuery, Prototype, Dojo. Don't work (immediately returns without any errors)
 * if standard AJAX API or one of other frameworks is used to send XML HTTP request.
 *
 * @param timeout Timeout in milliseconds.
 * @throws SeleniumError If timeout is reached.
 */</span>
<span class="nx">Selenium</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">doWaitForAjaxRequests</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Selenium</span><span class="p">.</span><span class="nx">decorateFunctionWithTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

        <span class="kd">var</span> <span class="nx">userWindow</span> <span class="o">=</span> <span class="nx">selenium</span><span class="p">.</span><span class="nx">browserbot</span><span class="p">.</span><span class="nx">getUserWindow</span><span class="p">();</span>
        <span class="kd">var</span> <span class="nx">isJqueryComplete</span> <span class="o">=</span> <span class="k">typeof</span><span class="p">(</span><span class="nx">userWindow</span><span class="p">.</span><span class="nx">jQuery</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">'function'</span>
            <span class="o">||</span> <span class="nx">userWindow</span><span class="p">.</span><span class="nx">jQuery</span><span class="p">.</span><span class="nx">active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">isPrototypeComplete</span> <span class="o">=</span> <span class="k">typeof</span><span class="p">(</span><span class="nx">userWindow</span><span class="p">.</span><span class="nx">Ajax</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">'function'</span>
            <span class="o">||</span> <span class="nx">userWindow</span><span class="p">.</span><span class="nx">Ajax</span><span class="p">.</span><span class="nx">activeRequestCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">isDojoComplete</span> <span class="o">=</span> <span class="k">typeof</span><span class="p">(</span><span class="nx">userWindow</span><span class="p">.</span><span class="nx">dojo</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">'function'</span>
            <span class="o">||</span> <span class="nx">userWindow</span><span class="p">.</span><span class="nx">dojo</span><span class="p">.</span><span class="nx">io</span><span class="p">.</span><span class="nx">XMLHTTPTransport</span><span class="p">.</span><span class="nx">inFlight</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">isJqueryComplete</span> <span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span> <span class="nx">isPrototypeComplete</span> <span class="o">&amp;&amp;</span> <span class="nx">isDojoComplete</span><span class="p">;</span>
    <span class="p">},</span> <span class="nx">timeout</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure><p>Если для написания тестов используется не <a href="http://seleniumhq.org/docs/04_selenese_commands.html">Selenese</a>, а нормальный язык программирования, то для того, чтобы можно было воспользоваться новым методом, необходимо расширить используемый драйвер, добавив в него этот метод.<p>Теперь мы можем легко заменить такой вот код теста:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="o">...</span>
<span class="n">selenium</span><span class="o">.</span><span class="na">check</span><span class="o">(</span><span class="s">"name=enableBender"</span><span class="o">);</span>
<span class="n">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>
<span class="n">selenium</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">"name=mode"</span><span class="o">,</span> <span class="s">"label=Kill all humans"</span><span class="o">);</span>
<span class="o">...</span></code></pre></figure><p>На такой:<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="o">...</span>
<span class="n">selenium</span><span class="o">.</span><span class="na">check</span><span class="o">(</span><span class="s">"name=enableBender"</span><span class="o">);</span>
<span class="n">selenium</span><span class="o">.</span><span class="na">waitForAjaxRequests</span><span class="o">(</span><span class="mi">60000</span><span class="o">);</span>
<span class="n">selenium</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">"name=mode"</span><span class="o">,</span> <span class="s">"label=Kill all humans"</span><span class="o">);</span>
<span class="o">...</span></code></pre></figure><p>И тесты будут выполняться со скоростью, равной скорости ответа сервера, т.е. без лишних задержек.<p>Для некоторых проектов, где AJAX-запросы начинают выполняться сразу после загрузки страницы (да, бывают и такие), рекомендую перегрузить методы waitForPageToLoad, waitForFrameToLoad и waitForPopUp, добавив в них последним вызовом waitForAjaxRequests, чтобы не дергать его постоянно в тестах.<p>Напоследок ещё раз повторюсь, что в стандартном API нет возможности установки глобальных перехватчиков AJAX-запросов, поэтому данный метод не будет работать, если разработчики используют стандартный API напрямую. Благо, что в более-менее серьёзных проектах так не поступают. Но вполне возможно, что в каком-нибудь проекте применяется собственная обёртка вокруг стандартного API, в таком случае надо будет просто поддержать эту обёртку в user-extensions.js. </span><div id="page-meta" class="t30"><p> <time class="icon-calendar pr20" datetime="2011-01-11" itemprop="datePublished"> 11 января 2011 </time> <span class="icon-archive pr20">&nbsp;<a href="https://webdriver.ru/blog/">БЛОГ</a></span> <br /> <span class="pr20"></span><ul class="pager"><li><a href="https://webdriver.ru/blog/2011-01-11-selenium-pageshots/">&larr; Selenium: Снятие скриншотов веб-страницы целиком</a><li>&nbsp;|&nbsp;<li><a href="https://webdriver.ru/blog/2011-01-18-selenium-google-chrome-same-origin-policy/">Selenium: как отключить same origin policy в браузере Google Chrome &rarr;</a></ul></div></article></div><div class="medium-4 columns"><aside><div class="panel radius"><h3>Новые публикации</h3><ul class="side-nav"><li><a href="https://webdriver.ru/news/2019-11-25-seleniumconf-london/">Опубликованы материалы конференции SeleniumConf London 2019</a><li><a href="https://webdriver.ru/news/2019-11-18-selenium-dev/">Запущен новый сайт selenium.dev</a><li><a href="https://webdriver.ru/news/2018-07-10-selenium-314/">Вышел релиз Selenium 3.14</a><li><a href="https://webdriver.ru/news/2018-07-10-selenium-313/">Вышел релиз Selenium 3.13</a><li><a href="https://webdriver.ru/news/2018-06-25-selenium-312/">Вышел релиз Selenium 3.12</a></ul></div><div class="panel radius"><h3>Ближайшие тренинги</h3><ul class="side-nav"><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/242-selenium-webdriver"><time class="icon-calendar date"> 18 июня 2021</time><br>Selenium WebDriver: полное руководство</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/226-csharp-for-testers"><time class="icon-calendar date"> 25 июня 2021</time><br>Программирование на C# для тестировщиков</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/19-performance-testing-jmeter"><time class="icon-calendar date"> 2 июля 2021</time><br>Тестирование производительности: JMeter 5</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/185-selenium"><time class="icon-calendar date"> 9 июля 2021</time><br>Selenium IDE 3: стартовый уровень</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/1-java-for-testers"><time class="icon-calendar date"> 9 июля 2021</time><br>Программирование на Java для тестировщиков</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/46-test-design"><time class="icon-calendar date"> 16 июля 2021</time><br>Практикум по тест-дизайну 2.0</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/189-web"><time class="icon-calendar date"> 16 июля 2021</time><br>Тестирование веб-приложений 2.0</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/234-functional-test-automation"><time class="icon-calendar date"> 23 июля 2021</time><br>Автоматизация функционального тестирования</a></span><li> <span class="course-title"><a href="http://software-testing.ru/edu/3-online/233-python"><time class="icon-calendar date"> 23 июля 2021</time><br>Программирование на Python для тестировщиков</a></span></ul></div></aside></div></div><footer id="footer-content" class="bg-grau"><div id="footer"><div class="row"><div class="medium-6 large-5 columns"><h5 class="shadow-black">О нас</h5><ul class="no-bullet shadow-black"><li><a href="https://webdriver.ru/info/">Пишем про Selenium на русском языке</a></ul></div><div class="small-6 medium-3 large-3 large-offset-1 columns"><h5 class="shadow-black">RSS/Atom</h5><ul class="no-bullet shadow-black"><li > <a href="" title=""></a><li > <a href="/feed.xml" title="Subscribe to RSS Feed">RSS</a><li > <a href="/atom.xml" title="Subscribe to Atom Feed">Atom</a></ul></div><div class="small-6 medium-3 large-3 columns"><h5 class="shadow-black">Благодарности</h5><ul class="no-bullet shadow-black"><li > <a href="" title=""></a><li class="services-newsletter" > <a href="https://jekyllrb.com/" target="_blank" title="Built with Jekyll">Built with Jekyll</a><li class="services-newsletter" > <a href="https://github.com/Phlow/feeling-responsive" target="_blank" title="Design by Phlow">Design by Phlow</a><li class="services-newsletter" > <a href="http://foundation.zurb.com/" target="_blank" title="Built on Foundation">Built on Foundation</a></ul></div></div></div><div id="subfooter"><nav class="row"><section id="subfooter-left" class="b30 small-12 medium-6 columns credits"></section><section id="subfooter-right" class="small-12 medium-6 columns social-icons"><ul class="inline-list"></ul></section></nav></div></footer><script src="https://webdriver.ru/assets/js/javascript.min.js"></script></div>
